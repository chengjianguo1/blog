<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3.NPM 中常用命令 | 运维及前端知识整理</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="文件上传组件 vue文件上传 多文件上传">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b6bfb1ac.css" as="style"><link rel="preload" href="/blog/assets/js/app.19024b16.js" as="script"><link rel="preload" href="/blog/assets/js/2.4ac9db42.js" as="script"><link rel="preload" href="/blog/assets/js/22.29548e90.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.5f05e4bc.js"><link rel="prefetch" href="/blog/assets/js/11.8cbb3676.js"><link rel="prefetch" href="/blog/assets/js/12.03608f82.js"><link rel="prefetch" href="/blog/assets/js/13.ae31a07d.js"><link rel="prefetch" href="/blog/assets/js/14.7aec61b2.js"><link rel="prefetch" href="/blog/assets/js/15.3f8cc38f.js"><link rel="prefetch" href="/blog/assets/js/16.8b056a43.js"><link rel="prefetch" href="/blog/assets/js/17.6ca74702.js"><link rel="prefetch" href="/blog/assets/js/18.3945b18f.js"><link rel="prefetch" href="/blog/assets/js/19.5557b8cb.js"><link rel="prefetch" href="/blog/assets/js/20.4e7c7796.js"><link rel="prefetch" href="/blog/assets/js/21.1bf71de7.js"><link rel="prefetch" href="/blog/assets/js/23.add44d64.js"><link rel="prefetch" href="/blog/assets/js/24.80bde89b.js"><link rel="prefetch" href="/blog/assets/js/25.78d90620.js"><link rel="prefetch" href="/blog/assets/js/26.99827223.js"><link rel="prefetch" href="/blog/assets/js/27.2f512229.js"><link rel="prefetch" href="/blog/assets/js/28.01e7809a.js"><link rel="prefetch" href="/blog/assets/js/29.af9a8e11.js"><link rel="prefetch" href="/blog/assets/js/3.74a85236.js"><link rel="prefetch" href="/blog/assets/js/30.babf68d7.js"><link rel="prefetch" href="/blog/assets/js/31.38c5f139.js"><link rel="prefetch" href="/blog/assets/js/32.dd33678a.js"><link rel="prefetch" href="/blog/assets/js/33.c1d3c72b.js"><link rel="prefetch" href="/blog/assets/js/34.1d0d9a52.js"><link rel="prefetch" href="/blog/assets/js/35.7a2d7357.js"><link rel="prefetch" href="/blog/assets/js/36.ce9b60b3.js"><link rel="prefetch" href="/blog/assets/js/37.0da3ad1b.js"><link rel="prefetch" href="/blog/assets/js/38.ec9f441a.js"><link rel="prefetch" href="/blog/assets/js/39.854305ce.js"><link rel="prefetch" href="/blog/assets/js/4.04976430.js"><link rel="prefetch" href="/blog/assets/js/40.bfabdfdf.js"><link rel="prefetch" href="/blog/assets/js/41.48544c6e.js"><link rel="prefetch" href="/blog/assets/js/42.4738b895.js"><link rel="prefetch" href="/blog/assets/js/43.1b23e6fd.js"><link rel="prefetch" href="/blog/assets/js/44.c06f5d4c.js"><link rel="prefetch" href="/blog/assets/js/45.bd44d57e.js"><link rel="prefetch" href="/blog/assets/js/46.5d7a06da.js"><link rel="prefetch" href="/blog/assets/js/47.28a3484a.js"><link rel="prefetch" href="/blog/assets/js/48.cbf61cca.js"><link rel="prefetch" href="/blog/assets/js/49.46876c92.js"><link rel="prefetch" href="/blog/assets/js/5.d735502a.js"><link rel="prefetch" href="/blog/assets/js/50.7fc2c3ce.js"><link rel="prefetch" href="/blog/assets/js/51.7a88a24e.js"><link rel="prefetch" href="/blog/assets/js/52.4f09d156.js"><link rel="prefetch" href="/blog/assets/js/53.7ed4e828.js"><link rel="prefetch" href="/blog/assets/js/54.5ce05f50.js"><link rel="prefetch" href="/blog/assets/js/55.1a31bf87.js"><link rel="prefetch" href="/blog/assets/js/56.a78058d3.js"><link rel="prefetch" href="/blog/assets/js/57.afb7f5a3.js"><link rel="prefetch" href="/blog/assets/js/58.d21c783d.js"><link rel="prefetch" href="/blog/assets/js/59.23dc99cf.js"><link rel="prefetch" href="/blog/assets/js/6.da78d201.js"><link rel="prefetch" href="/blog/assets/js/60.5500c9dc.js"><link rel="prefetch" href="/blog/assets/js/61.822c2676.js"><link rel="prefetch" href="/blog/assets/js/62.30cce9e7.js"><link rel="prefetch" href="/blog/assets/js/63.4dfcb47c.js"><link rel="prefetch" href="/blog/assets/js/64.b76d89c0.js"><link rel="prefetch" href="/blog/assets/js/65.6491f519.js"><link rel="prefetch" href="/blog/assets/js/66.50af43d6.js"><link rel="prefetch" href="/blog/assets/js/7.bdc92cc3.js"><link rel="prefetch" href="/blog/assets/js/8.ac4ddad8.js"><link rel="prefetch" href="/blog/assets/js/9.2cd3555e.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b6bfb1ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">运维及前端知识整理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Jenkins</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mac Book</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Node</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/node/1.node基本概念.html" class="sidebar-link">1.node 基本概念</a></li><li><a href="/blog/node/2.node中的模块.html" class="sidebar-link">2.Node中的模块</a></li><li><a href="/blog/node/3.npm中常用的命令.html" class="active sidebar-link">3.NPM 中常用命令</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-1-npm-init" class="sidebar-link">3.1 npm init</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-2-npm-install" class="sidebar-link">3.2 npm install</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-2-本地安装" class="sidebar-link">3.2 本地安装</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-3-package-lock-文件" class="sidebar-link">3.3 package-lock 文件</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-4-依赖方式" class="sidebar-link">3.4 依赖方式</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-5-npm-版本管理" class="sidebar-link">3.5 npm 版本管理</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-6-scripts-配置" class="sidebar-link">3.6 scripts 配置</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-7-协议" class="sidebar-link">3.7 协议</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-8-npx-用法" class="sidebar-link">3.8 npx 用法</a></li><li class="sidebar-sub-header"><a href="/blog/node/3.npm中常用的命令.html#_3-9-包的发布" class="sidebar-link">3.9 包的发布</a></li></ul></li><li><a href="/blog/node/4.http.html" class="sidebar-link">4.HTTP</a></li><li><a href="/blog/node/5.http在header中的应用.html" class="sidebar-link">5.HTTP 在 Header 中的应用</a></li><li><a href="/blog/node/6.Express应用+原理.html" class="sidebar-link">6.Express 应用+原理</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Shell</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vi</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_3-npm-中常用命令"><a href="#_3-npm-中常用命令" class="header-anchor">#</a> 3.NPM 中常用命令</h1> <p>全称 node package manager 是世界上最大规模的包管理系统,官网是这样介绍的 Build amazing things...</p> <h2 id="_3-1-npm-init"><a href="#_3-1-npm-init" class="header-anchor">#</a> 3.1 npm init</h2> <p>默认大家肯定比较熟悉了，直接 npm init -y 了事，这回我们再来仔细看看</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;my-pack&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;index.js&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string">&quot;license&quot;</span><span class="token operator">:</span> <span class="token string">&quot;ISC&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里先声明的 npm 版本是 6.7.0,因为我的 node 版本是 v11.14.0</p> <p>咱们来一个个说说这里比较重要的字段:<code>name</code>、<code>version</code>、<code>main</code>、<code>scripts</code>、<code>license</code></p> <ul><li>name 是当前包的名字，也就是最终发布的 npm 官网上包的名字。不能和已有的包重名哦</li> <li>version 就是当前包的版本号，主要我们要探究如果优雅的管理版本号</li> <li>main 就是当前包的入口文件，也就是使用 require 默认引入的文件</li> <li>scripts 可以配置一些执行脚本</li> <li>license 协议许可</li></ul> <h2 id="_3-2-npm-install"><a href="#_3-2-npm-install" class="header-anchor">#</a> 3.2 npm install</h2> <p>全局安装</p> <div class="language-js extra-class"><pre class="language-js"><code>npm install http<span class="token operator">-</span>server <span class="token operator">-</span>g
</code></pre></div><p>全局安装的意思很简单,就是安装的模块会被安装到全局下，可以在命令行中直接使用安装的包,其实只是在**/user/local/bin 目录下作了个链接连接到 /usr/local/lib/node_modules/http-server/bin/http-server 这个文件，当我们执行 http-server**这个命令时，会调用链接的这个文件。</p> <p>mac 因为有权限问题，这里我们加<code>sudo</code>来执行命令</p> <p>我们可以自己来尝试写一个包 ,创建 bin 目录，新增 www 文件,名字叫什么无所谓~</p> <div class="language-js extra-class"><pre class="language-js"><code>#<span class="token operator">!</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// #! 这句表示采用node来执行此文件，同理 shell可以表示 sh</span>
</code></pre></div><p>更新 package.json 文件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;bin&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;my-pack&quot;</span><span class="token operator">:</span><span class="token string">&quot;./bin/www&quot;</span> <span class="token comment">// 这里要注意名字和你建立的文件夹相同</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>好啦，写好啦！这里我们先不说发包的事，先用一个常用的命令，他可以实现链接的功能</p> <div class="language-js extra-class"><pre class="language-js"><code>npm link
</code></pre></div><p>这样我们在命令行中直接输入 my-pack 就可以 打印出<code>test</code></p> <h2 id="_3-2-本地安装"><a href="#_3-2-本地安装" class="header-anchor">#</a> 3.2 本地安装</h2> <div class="language-js extra-class"><pre class="language-js"><code>npm install webpack <span class="token operator">--</span>save<span class="token operator">-</span>dev
</code></pre></div><p>本地安装很好理解啦~ 就是所谓的在项目中使用，而非在命令行中使用！这里我们看到生成了一个<strong>package-lock.json</strong>文件，而且将安装的模块放到了<strong>node_modules</strong>下,而且 json 中也新增了些内容</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;devDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;webpack&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.39.3&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们先来简单介绍下基本的使用</p> <p><code>--save-dev</code>代表当前依赖只在开发时被应用,如果默认不写相当于 <code>--save</code>为项目依赖开发上线都需要</p> <p>也可以指定版本号来安装包</p> <div class="language-js extra-class"><pre class="language-js"><code>npm i jquery@<span class="token number">2.2</span><span class="token number">.0</span> # install可以简写成i
</code></pre></div><p>默认执行<code>npm i</code>会安装项目中所需要的依赖,如果只想安装生产环境依赖可以增加<code>--production</code>参数</p> <h2 id="_3-3-package-lock-文件"><a href="#_3-3-package-lock-文件" class="header-anchor">#</a> 3.3 package-lock 文件</h2> <p>自 npm 5 之后所有的依赖包都采用扁平化管理的方式
<code>package-lock.json</code> 的作用是锁定依赖安装结构,保证在任意机器上执行 <code>npm install</code> 都会得到完全相同的 <code>node_modules</code> 结果,因为<code>package-lock.json</code>存储所有安装的信息</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;my-pack&quot;</span><span class="token punctuation">,</span>
<span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
<span class="token string">&quot;lockfileVersion&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token string">&quot;requires&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token string">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
<span class="token string">&quot;@webassemblyjs/ast&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.8.5&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 当前依赖的版本</span>
    <span class="token string">&quot;resolved&quot;</span><span class="token operator">:</span> <span class="token string">&quot;https://registry.npm.taobao.org/@webassemblyjs/ast/download/@webassemblyjs/ast-1.8.5.tgz&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 从哪个渠道安装的</span>
    <span class="token string">&quot;integrity&quot;</span><span class="token operator">:</span> <span class="token string">&quot;sha1-UbHF/mV2o0lTv0slPfnw1JDZ41k=&quot;</span><span class="token punctuation">,</span> <span class="token comment">// 内容hash</span>
    <span class="token string">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token string">&quot;requires&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;@webassemblyjs/helper-module-context&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.8.5&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;@webassemblyjs/helper-wasm-bytecode&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.8.5&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;@webassemblyjs/wast-parser&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.8.5&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token operator">...</span><span class="token punctuation">.</span>
</code></pre></div><p>如果手动更新了<code>package.json</code>文件,执行安装命令会下载对应的新版本,并且会自动更新 lock 文件~</p> <h2 id="_3-4-依赖方式"><a href="#_3-4-依赖方式" class="header-anchor">#</a> 3.4 依赖方式</h2> <p>简单介绍下常见的依赖方式：</p> <ul><li><p>1.dependencies 项目依赖
可以使用<code>npm install -S</code>或 <code>npm install --save</code>保存到依赖中，当发布到 npm 上时 dependencies 下的模块会作为依赖，一起被下载!</p></li> <li><p>2.devDependencies 开发依赖
可以使用<code>npm install -D</code>或 <code>npm install --save-dev</code>保存到依赖中。 当发布到 npm 上时 devDependencies 下面的模块就不会自动下载了,如果只是单纯的开发项目 dependencies,devDependencies 只有提示的作用!</p></li></ul> <ul><li>3.peerDependencies 同版本依赖
同等依赖,如果你安装我，那么你最好也安装我对应的依赖，如果未安装会报出警告 <code>bash &quot;peerDependencies&quot;: { &quot;jquery&quot;: &quot;2.2.0&quot; }</code></li></ul> <blockquote><p>npm WARN youxuan@1.0.0 requires a peer of jquery@2.2.0 but none is installed. You must install peer dependencies yourself.</p></blockquote> <ul><li><ol start="4"><li>bundledDependencies 捆绑依赖</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;bundleDependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;jquery&quot;</span>
 <span class="token punctuation">]</span><span class="token punctuation">,</span>
</code></pre></div><p>使用<code>npm pack</code>打包 tgz 时会将捆绑依赖一同打包</p> <ul><li>3.5 optionalDependencies 可选依赖
如果发现无法安装或无法找到，不会影响 npm 的安装</li></ul> <h2 id="_3-5-npm-版本管理"><a href="#_3-5-npm-版本管理" class="header-anchor">#</a> 3.5 npm 版本管理</h2> <p>npm 采用了 semver 规范作为依赖版本管理方案。semver 约定一个包的版本号必须包含 3 个数字</p> <blockquote><p><code>MAJOR.MINOR.PATCH</code> 意思是 <code>主版本号.小版本号.修订版本号</code></p></blockquote> <ul><li>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号</li> <li>MINOR 对应小版本迭代，发生兼容旧版 API 的修改或功能更新时，更新 MINOR 版本号
PATCH 对应修订版本号，一般针对修复 BUG 的版本号</li></ul> <p>当我们每次发布包的时候都需要升级版本号</p> <div class="language-js extra-class"><pre class="language-js"><code>npm version major  # 大版本号加 <span class="token number">1</span>，其余版本号归 <span class="token number">0</span>
npm version minor  # 小版本号加 <span class="token number">1</span>，修订号归 <span class="token number">0</span>
npm version patch  # 修订号加 <span class="token number">1</span>
</code></pre></div><p>如果使用 git 管理项目会自动 <code>git tag</code> 标注版本号</p> <p>来看看版本号的标识含义:</p> <table><thead><tr><th>range</th> <th>含义</th> <th>示例</th></tr></thead> <tbody><tr><td><code>^2.2.1</code></td> <td>指定的 MAJOR 版本号下, 所有更新的版本</td> <td> 匹配 <code>2.2.3</code>, <code>2.3.0</code>; 不匹配 <code>1.0.3</code>, <code>3.0.1</code></td></tr> <tr><td><code>~2.2.1</code></td> <td>指定 MAJOR.MINOR 版本号下，所有更新的版本</td> <td>匹配 <code>2.2.3</code>, <code>2.2.9</code> ; 不匹配 <code>2.3.0</code>, <code>2.4.5</code></td></tr> <tr><td><code>&gt;=2.1</code></td> <td>版本号大于或等于 <code>2.1.0</code></td> <td>匹配 <code>2.1.2</code>, <code>3.1</code></td></tr> <tr><td><code>&lt;=2.2</code></td> <td>版本号小于或等于 <code>2.2</code></td> <td>匹配 <code>1.0.0</code>, <code>2.2.1</code>, <code>2.2.11</code></td></tr> <tr><td><code>1.0.0 - 2.0.0</code></td> <td>版本号  从 1.0.0 (含) 到 2.0.0 (含)</td> <td>匹配 <code>1.0.0</code>, <code>1.3.4</code>, <code>2.0.0</code></td></tr></tbody></table> <p>预发版：</p> <ul><li><p>alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多 bug；一般只有测试人员使用。</p></li> <li><p>beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在 alpha 版之后推出。</p></li> <li><p>rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</p></li></ul> <p><code>2.1.0-beta.1</code>这样声明的版本用户不会立马使用，可以用来做测试使用</p> <h2 id="_3-6-scripts-配置"><a href="#_3-6-scripts-配置" class="header-anchor">#</a> 3.6 scripts 配置</h2> <p>在 package.json 中可以定义自己的脚本通过 npm run 来执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
   <span class="token string">&quot;hello&quot;</span><span class="token operator">:</span> <span class="token string">&quot;echo hello&quot;</span><span class="token punctuation">,</span>
   <span class="token string">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;webpack&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以使用 <code>npm run hello</code>执行脚本,也可以使用 <code>npm run build</code>执行<code>node_modules/.bin</code>目录下的 webpack 文件</p> <ul><li><p><code>npm run</code> 命令执行时，会把 <code>./node_modules/.bin/</code> 目录添加到执行环境的 <code>PATH</code> 变量中，因此如果某个命令行包未全局安装，而只安装在了当前项目的 <code>node_modules</code> 中，通过 <code>npm run</code> 一样可以调用该命令。</p></li> <li><p>执行 npm 脚本时要传入参数，需要在命令后加 -- 标明, 如 <code>npm run hello -- --port 3000</code> 可以将 <code>--port</code> 参数传给<code>hello</code> 命令</p></li> <li><p>npm 提供了 pre 和 post 两种钩子机制，可以定义某个脚本前后的执行脚本,没有定义默认会忽略</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
   <span class="token string">&quot;prehello&quot;</span><span class="token operator">:</span><span class="token string">&quot;echo prehello&quot;</span><span class="token punctuation">,</span>
   <span class="token string">&quot;hello&quot;</span><span class="token operator">:</span> <span class="token string">&quot;echo hello&quot;</span><span class="token punctuation">,</span>
   <span class="token string">&quot;posthello&quot;</span><span class="token operator">:</span><span class="token string">&quot;echo posthello&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以通过打印<code>全局env</code>和 在项目下执行<code>npm run env</code>来对比<code>PATH</code>属性，不难发现在执行 npm run 的时候确实会将<code>./node_modules/.bin/</code> 目录添加到 PATH 中</p> <h2 id="_3-7-协议"><a href="#_3-7-协议" class="header-anchor">#</a> 3.7 协议</h2> <p><img src="/blog/assets/img/3.656b8355.png" alt="效果图" title="效果图">
不废话，这张图就说明了为什么 MIT 许可是最大的了!</p> <h2 id="_3-8-npx-用法"><a href="#_3-8-npx-用法" class="header-anchor">#</a> 3.8 npx 用法</h2> <p>npx 命令是 npm v5.2 之后引入的新命令，npx 可以帮我们直接执行<code>node_modules/.bin</code>文件夹下的文件</p> <ul><li><strong>1.执行脚本</strong></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>npx webpack
</code></pre></div><p>是不是省略了配置<code>scripts</code>脚本啦！</p> <ul><li><strong>2.避免安装全局模块</strong> <br>
全局安装的模块会带来很多问题，例如：多个用户全局安装的模块版本不同</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>npx create<span class="token operator">-</span>react<span class="token operator">-</span>app react<span class="token operator">-</span>project
</code></pre></div><p>我们可以直接使用 <code>npx</code> 来执行模块，它会先进行安装，安装执行后会将下载过的模块删除~，这样可以一直使用最新版本啦~</p> <h2 id="_3-9-包的发布"><a href="#_3-9-包的发布" class="header-anchor">#</a> 3.9 包的发布</h2> <p>包的发布比较简单，首先我们需要先切换到官方源,这里推荐个好用的工具 nrm</p> <div class="language-js extra-class"><pre class="language-js"><code>npm install nrm <span class="token operator">-</span>g
nrm use npm # 切换到官方源
</code></pre></div><p>之后更新名字哈，这里也可以发布 <a href="https://docs.npmjs.com/creating-and-publishing-scoped-public-packages/" target="_blank" rel="noopener noreferrer">作用域包<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 选定版本后,忽略文件夹可以使用 .npmignore,一切就绪后，发布！！！</p> <div class="language-js extra-class"><pre class="language-js"><code>npm publish
</code></pre></div><p>ok，我们的包就可以成功的发布到 npm 上啦~</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/node/2.node中的模块.html" class="prev">
        2.Node中的模块
      </a></span> <span class="next"><a href="/blog/node/4.http.html">
        4.HTTP
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.19024b16.js" defer></script><script src="/blog/assets/js/2.4ac9db42.js" defer></script><script src="/blog/assets/js/22.29548e90.js" defer></script>
  </body>
</html>
